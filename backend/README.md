
![header](https://capsule-render.vercel.app/api?type=venom&color=auto&height=300&section=header&text=CalIT&fontSize=50&desc=📆Optimize%20Your%20Workspace%20Scrum%20Management&descAlignY=60)

# 👀 팀원 구성

<br>

|                    **👑차윤슬**                      |                  **박성준**                   |                 **최승은**                  |                     **강혜정**                     |             **지연희**              |
|:------------------------------------------------:|:------------------------------------------:|:----------------------------------------:|:-----------------------------------------------:|:--------------------------------:|
| <img src="https://github.com/user-attachments/assets/8d255376-5ae9-4685-8f11-cd4b18a4bb55" width="128px"/> | <img src="https://github.com/user-attachments/assets/f49055cf-2b4d-41ac-bb7d-98b47d257c4b" width="128px"/> | <img src="https://github.com/user-attachments/assets/21e6cee5-c2f0-4c94-9a0a-938053c5342b" width="128px"/> | <img src="https://github.com/user-attachments/assets/813020ee-ef97-4f44-becd-38ef55a778b1" width="128px"/> | <img src="https://github.com/user-attachments/assets/cefb90f7-237b-4613-b6e2-89e1c40c00f3" width="128px"/> |
| [@yunseul-dev](https://github.com/yunseul-dev) | [@seongxun](https://github.com/seongxun) | [@xeunnie](https://github.com/xeunnie) | [ @hyejeung](https://github.com/hyejeung) | [@Aqulog](https://github.com/Aqulog) |



# ⚒️ 기술 스택



### 백엔드
<img src="https://img.shields.io/badge/SpringBoot-181717?style=flat&logo=SpringBoot&logoColor=6DB33F&color=white" alt=""> <img src="https://img.shields.io/badge/Spring_Security-181717?style=flat&logo=SpringSecurity&logoColor=6DB33F&color=white" alt=""> <img src="https://img.shields.io/badge/JSON_Web_Tokens-181717?style=flat&logo=JSONWebTokens&logoColor=000000&color=white" alt=""> <img src="https://img.shields.io/badge/Spring-181717?style=flat&logo=Spring&logoColor=6DB33F&color=white" alt=""> <img src="https://img.shields.io/badge/Spring_Batch-181717?style=flat&logo=Spring&logoColor=6DB33F&color=white" alt=""> <img src="https://img.shields.io/badge/Apache_Kafka-181717?style=flat&logo=ApacheKafka&logoColor=231F20&color=white" alt=""> <img src="https://img.shields.io/badge/n8n-181717?style=flat&logo=n8n&logoColor=0F74E2&color=white" alt="">
### 데이터베이스
<img src="https://img.shields.io/badge/MariaDB-181717?style=flat&logo=MariaDB&logoColor=003545&color=white" alt=""> <img src="https://img.shields.io/badge/PostgreSQL-181717?style=flat&logo=PostgreSQL&logoColor=336791&color=white" alt=""> <img src="https://img.shields.io/badge/Redis-181717?style=flat&logo=Redis&logoColor=DC382D&color=white" alt="">


---



# 🎯 소프트웨어 아키텍처
<details>
  <summary><b>멀티모듈 아키텍처</b></summary>
  
  - 레이어드 아키텍처(Layerd Architecture)
  
  > 소프트웨어를 여러개의 계층으로 분리해서 설계하는 것

1. 레이어마다 정해진 역할이 있어서 레이어 간의 책임을 두고 분리해서 유지보수가 용이함
2. 레이어 간의 의존 흐름이 일정함
3. 새로운 기능을 개발할 때 통일된 흐름에 맞게 빠르게 개발이 가능함

  - 멀티모듈 아키텍처(MultyModule Architecture)
  
  > 여러 개의 작은 단위의 Module을 만들어서 하나의 앱을 만드는 것
1. 공통 모듈을 여러 프로젝트에서 재사용할 수 있어 코드 중복을 줄일 수 있음
2. 각 모듈이 독립적으로 개발되고 배포될 수 있어 개발 및 테스트의 효율성이 향상됨
3. 기존 모듈을 확장하기 쉽기 때문에 전체 시스템의 복잡성을 효율적으로 관리 가능함

   ![image](https://github.com/user-attachments/assets/82bd3499-57d8-4351-ba8d-20ab1c13213b)

   
  ### 레이어드 아키텍처 + 멀티모듈 아키텍처
  > 레이어드 아키텍처를 기반으로 API 서버와 공통 모듈로 구성된 멀티 모듈 구조를 채택 함으로써 API 서버는
> 주요 비지니스 로직을 담당하고,
> 공통 모듈은 엔티티와 같은 재사용 가능한 컴포넌트를 관리하여 모듈간의 중복을 줄이고 코드의 재사용성을 높였습니다.
</details>


<br>

# ✨ 주요 기능
<details>
  <summary><b>캘린더</b></summary>
  <div markdown="1">
설명

![calit](https://github.com/user-attachments/assets/082d561a-744e-4db4-99f6-8a764ceba503)

  </div>
</details>
<details>
  <summary><b>번다운 차트</b></summary>
  <div markdown="1">
설명

![calit](https://github.com/user-attachments/assets/082d561a-744e-4db4-99f6-8a764ceba503)

  </div>
</details>
<details>
  <summary><b>대쉬보드</b></summary>
  <div markdown="1">
설명

![calit](https://github.com/user-attachments/assets/082d561a-744e-4db4-99f6-8a764ceba503)

  </div>
</details>
<details>
  <summary><b>채팅</b></summary>
  <div markdown="1">
설명
    
![calit](https://github.com/user-attachments/assets/082d561a-744e-4db4-99f6-8a764ceba503)

  </div>
</details>
<details>
  <summary><b>알람</b></summary>
  <div markdown="1">
설명

![calit](https://github.com/user-attachments/assets/082d561a-744e-4db4-99f6-8a764ceba503)

### Spring Batch를 통한 알람 기능 개선

> 기존에는 **`@Scheduled`** 어노테이션을 사용한 스케줄링 방식으로 리마인드 알람을 구현했지만, 서버 부하와 메모리 사용량 증가로 인해 안정적인 서비스 제공에 어려움이 있었다. 이를 해결하기 위해 Spring Batch를 도입하여 알람 기능을 개선했다.

### 배치 적용 후 개선 사항

1. **역할 분리**
    
    Spring Batch의 Job, Step, Chunk 구조를 사용하여 리마인드 알람 기능을 단계별로 구현했다. 각 알람 유형(회의, 스프린트, 태스크)에 대해 독립적인 배치 작업을 설정하여 관리함으로써 코드의 책임을 명확히 하고 작업의 독립성을 유지했다.
    
    - **ItemReader**: 데이터베이스에서 회의, 스프린트, 태스크의 마감일 기준으로 알람 대상 데이터를 조회한다.
    - **ItemProcessor**: 데이터를 검증하고 알람 메시지에 필요한 정보를 가공하여, 알람 시점에 맞는 데이터를 설정한다.
    - **ItemWriter**: 가공된 데이터를 Kafka를 통해 **`reminder-alarm`** 토픽으로 전송하여 알람 메시지를 처리한다.
2. **부하 분산**
    - 알람 처리 로직을 독립적인 배치 서버로 분리해 메인 서버의 부하를 줄이고, 작업 분산을 통해 안정적인 서비스를 제공했다.
    - 배치 서버에서 발생하는 오류가 메인 서버에 미치는 영향을 최소화했다.
3. **확장성 강화**
    - Spring Batch는 배치 모듈에서 알람 메시지를 Kafka를 통해 API 서버로 전달하고, API 서버는 클라이언트에게 알람을 전송한다.
    - 이는 배치 모듈과 실시간 알람 처리(SSE Emitter)의 의존성 문제를 해결하고, 모듈 간 결합도를 낮춰 확장성과 유연성을 높였다.
4. **Kubernetes CronJob을 통한 배치 스케줄링**
    - Kubernetes 환경에서 Spring Batch 작업을 주기적으로 실행하기 위해 CronJob을 사용했다.
    - CronJob을 통해 배치 작업을 정기적으로 실행하여 특정 시간에 맞춰 알람 기능을 수행했다.
  
   <img src="https://github.com/user-attachments/assets/c9c8d171-0eec-4994-8191-61fbcf3b764e" width="800" heigh="400" />


  
### 배치 적용 후 성능 비교
[배치 도입 전 테스트 결과] [배치 도입 후 테스트 결과]

  </div>
</details>
<details>
  <summary><b>회의록 공동작성</b></summary>
  <div markdown="1">

## 1. Redis

### 인메모리 데이터베이스
- **Redis**는 디스크 기반의 RDB와 달리 **인메모리**에서 데이터를 처리하여 **훨씬 빠른 성능**을 제공합니다.
- 일반적인 인메모리 DB와 달리 Redis는 **영속성**을 지원하여, 장애 발생 시에도 데이터를 복구할 수 있습니다.

### 회의록 공동작성 기능에 Redis 적용 이유
- **빠른 읽기 작업**이 중요한 실시간 공동 작성 환경에 적합해서 선택하였습니다.

### Lookaside 캐시 패턴
- **캐시에서 먼저 데이터를 조회**하고, 데이터가 없을 경우 DB에서 조회하여 캐시에 저장하는 방식입니다.
- 반복적인 읽기 작업에서 **성능 향상**을 기대할 수 있으며, **DB 조회 빈도**를 줄여, 캐시를 활용한 효율적인 읽기 작업이 가능합니다.

## 2. Kafka

### 세션 관리 기능
- 서버를 2대 운영하는 환경에서 **Kafka**를 활용하여 세션 관리 기능을 구현하였습니다.
- 클라이언트 간의 원활한 통신을 위해 Kafka를 선택하였으며, **Pub-Sub 모델**을 기반으로 클라이언트 간에 메시지를 주고받습니다.

### Kafka의 장점
- 동일한 **토픽을 구독한 클라이언트들**에게 메시지를 전송하여, **메시지의 일관성**과 **신뢰성**을 보장합니다.
- **서버 간 세션 연결**를 유지할 수 있습니다.

## 3. REDIS 적용 후 개선 사항

### Redis
- **실시간**으로 다수의 사용자가 동시에 문서를 편집할 때, **빠른 응답 시간**과 반복적인 읽기 작업에서 성능 향상을 제공합니다.
- 캐시를 통해 **DB 부하를 줄이고**, 빠르고 안정적인 데이터 접근을 보장합니다.

**수치 자료 넣기**



![image](https://github.com/user-attachments/assets/960b02a8-bf5a-4765-88b3-e10a04cc727f)


  </div>
</details>

<br>




